<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>AI Orb</title>
<style>
body{
  margin:0;
  background:#020617;
  overflow:hidden;
}

canvas{
  position:fixed;
  inset:0;
}
</style>
</head>
<body>

<canvas id="c"></canvas>

<script type="module">
import {
  FilesetResolver,
  HandLandmarker
} from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0";

const canvas = document.getElementById("c");
const ctx = canvas.getContext("2d");

function resize(){
  canvas.width = innerWidth;
  canvas.height = innerHeight;
}
resize(); onresize = resize;

// camera
const video = document.createElement("video");
const stream = await navigator.mediaDevices.getUserMedia({video:true});
video.srcObject = stream;
await video.play();

// mediapipe
const fileset = await FilesetResolver.forVisionTasks(
  "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm"
);

const hand = await HandLandmarker.createFromOptions(fileset,{
  baseOptions:{
    modelAssetPath:
    "https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task"
  },
  numHands:1,
  runningMode:"VIDEO"
});

// virtual sphere
let rotX = 0;
let rotY = 0;

function project(x,y,z){
  const scale = 500/(z+600);
  return {
    x: x*scale + canvas.width/2,
    y: y*scale + canvas.height/2
  };
}

function loop(){
  ctx.clearRect(0,0,canvas.width,canvas.height);

  const res = hand.detectForVideo(video, performance.now());

  if(res.landmarks){
    const h = res.landmarks[0];
    const cx = (h[9].x-0.5)*2;
    const cy = (h[9].y-0.5)*2;
    rotY = cx*1.5;
    rotX = cy*1.5;
  }

  // draw sphere
  const r = 180;
  for(let a=0;a<Math.PI*2;a+=0.3){
    for(let b=0;b<Math.PI;b+=0.3){
      let x = r * Math.sin(b) * Math.cos(a);
      let y = r * Math.cos(b);
      let z = r * Math.sin(b) * Math.sin(a);

      // rotate
      let dx = x*Math.cos(rotY)-z*Math.sin(rotY);
      let dz = x*Math.sin(rotY)+z*Math.cos(rotY);
      let dy = y*Math.cos(rotX)-dz*Math.sin(rotX);
      dz = y*Math.sin(rotX)+dz*Math.cos(rotX);

      const p = project(dx,dy,dz);
      ctx.beginPath();
      ctx.arc(p.x,p.y,2.5,0,Math.PI*2);
      ctx.fillStyle="#00f5ff";
      ctx.fill();
    }
  }

  requestAnimationFrame(loop);
}
loop();
</script>

</body>
</html>
